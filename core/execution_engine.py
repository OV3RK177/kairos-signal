import clickhouse_connect
import time
import random

# --- CONFIGURATION ---
LEVERAGE = 2.0  # 200% Leverage (2x)
LOT_SIZE = 1000.0 # Base trade size in USD equivalent

print(f"--- KAIROS EXECUTION: GLOBAL MACRO MODE (Lev: {LEVERAGE}x) ---", flush=True)
client = clickhouse_connect.get_client(host='localhost', port=8123, username='default', password='kairos')

def execute_trade(signal_data):
    """
    Simulates execution of ANY currency pair (EUR, GBP, JPY, etc.)
    """
    ticker = signal_data['ticker']
    price = float(signal_data['price'])
    side = signal_data['side'] # 'BUY' or 'SELL'
    
    # 1. Calculate Position Size
    # If trading EUR pair, we assume auto-conversion or margin usage
    position_value = LOT_SIZE * LEVERAGE
    quantity = position_value / price
    
    print(f"‚öîÔ∏è  EXECUTING: {side} {ticker} | Size: ${position_value} ({quantity:.4f} units)")
    
    # 2. Log to Ledger
    # We store it in signal_ledger so the Dashboard sees it
    try:
        query = f"""
        INSERT INTO signal_ledger (
            timestamp, 
            asset, 
            signal_type, 
            signal_price, 
            entry_price, 
            status,
            meta_data
        ) VALUES (
            now(), 
            '{ticker}', 
            '{side}', 
            {price}, 
            {price}, 
            'OPEN',
            '{{"leverage": {LEVERAGE}, "currency": "{ticker.split('_')[-1]}"}}'
        )
        """
        client.command(query)
        print(f"‚úÖ FILLED: {ticker} @ {price} (Ledger Updated)")
        
    except Exception as e:
        print(f"‚ùå EXECUTION FAILURE: {e}")

def monitor_signals():
    print("‚öîÔ∏è  Execution Engine Active. Waiting for signals...", flush=True)
    
    # We look for signals generated by the Cortex in the last 10 seconds
    # (In a real system, Cortex writes to a queue. Here we poll logs or use a shared state)
    # FOR THIS DEMO: We assume Cortex calls this function or writes to a 'pending_orders' table.
    
    # ... (Integration logic usually goes here) ...
    pass

# MOCK LISTENER (Since your Cortex prints to stdout, we need a bridge)
# In your current setup, Cortex prints "üö® SIGNAL". 
# The simplest way to bridge this without rewriting everything is to have Cortex 
# INSERT directly into a 'pending' table, or have this script parse logs.
#
# BUT, since your Cortex is ALREADY autonomous, let's assume it writes to DB.
# If it doesn't, we will update Cortex to WRITE trades, not just print them.

if __name__ == "__main__":
    monitor_signals()
